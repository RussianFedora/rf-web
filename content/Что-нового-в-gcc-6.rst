.. title: Что нового в GCC 6?
.. slug: Что-нового-в-gcc-6
.. date: 2016-02-26 13:12:24
.. tags:
.. category:
.. link:
.. description:
.. type: text
.. author: Peter Lemenkov

**Это архивная статья**


| `С появлением GCC 6 в Fedora
  24 </content/fedora-пересобирает-все-пакеты-с-gcc-6>`__ у мэйнтейнеров
  и простых пользователей Fedora возник вопрос - а что там такого
  нового, [STRIKEOUT:что ничего не работает]? `Нового
  много! <https://gcc.gnu.org/gcc-6/changes.html>`__
| Если же вам скучно читать `список
  изменений <https://gcc.gnu.org/gcc-6/changes.html>`__, и `подсказку по
  сборке ПО с новым GCC <https://gcc.gnu.org/gcc-6/porting_to.html>`__,
  то наши коллеги уже пару недель объясняют более доходчиво. Например,
  `статья <https://gnu.wildebeest.org/blog/mjw/2016/02/15/looking-forward-to-gcc6-many-new-warnings/>`__
  от `Mark J. Wielaard <https://www.openhub.net/accounts/mjw>`__,
  `статья <https://developerblog.redhat.com/2016/02/23/upcoming-features-in-gcc-6/>`__
  от `Jeff Law <https://www.openhub.net/accounts/JeffLaw>`__, и
  `статья <https://developerblog.redhat.com/2016/02/25/new-asm-flags-feature-for-x86-in-gcc-6/>`__
  от Richard Henderson.

| Мы отметим следующие новшества:

-  Переход на c++14 по умолчанию (предыдущие версии можно переключиться
   с помощью флагов компилятора).

-  Scalar Storage Order. Это способ указать byte-order при описании
   структуры, и при дальнейшем обращении с ней компилятор будет
   автоматически добавлять код для конвертации endianness. Порой может
   быть удобно, но специфично для конкретного компилятора. С битовыми
   полями, к сожалению, применять не получится.

-  Предупреждения о `misleading
   identation <http://www.dwheeler.com/essays/apple-goto-fail.html>`__ в
   коде.

-  Предупреждения, когда объект сравнивается с собой же. Например, if
   (point.x < 0 \|\| point.x < 0)... или while (res > res)... - тут,
   вероятно, опечатка, и теперь компилятор укажет на это. Тоже самое,
   если в If..Else..If блоках будут повторяющиеся условия, то компилятор
   укажет на них.

-  Компилятор теперь проверяет корректность операций побитового сдвига.

   По умолчанию предупреждает о сдвиговых операциях над отрицательными
   числами, и о слишком больших сдвигах (выходящих за пределы размера
   переменной, например, сдвиг на 30 байт 32-битного числа 10 потребует
   как минимум 35 битов). Можно включить и предупреждение о сдвигах за
   пределы знаковых переменных.

-  Дополнительная проверка на разыменование нулевого указателя.

-  `Offloading </content/gcc-получил-поддержку-offloading>`__.


| 
| Твой ход, LLVM!
| Кстати, а вы уже ознакомились `с
  рекомендациями <https://matt.sh/howto-c>`__ для современных
  C-программистов?
