.. title: Новый тип в SELinux - unconfined_service_t
.. slug: Новый-тип-в-selinux-unconfinedservicet
.. date: 2014-09-12 16:08:06
.. tags:
.. category:
.. link:
.. description:
.. type: text
.. author: Peter Lemenkov

**Это архивная статья**


| Внимательные пользователи Fedora 21 и RHEL 7 уже заметили появление
  нового типа в SELinux - *unconfined\_service\_t*. Dan Walsh `решил
  объяснить <https://danwalsh.livejournal.com/70577.html>`__, что это за
  штука такая.


    | Каждый, кто хоть раз использовал SELinux, знает, что домен
      *unconfined\_t*, это метка процесса, который не ограничивается
      (unconfined) [SELinux]. Но это не единственный неограничиваемый
      (unconfined) домен в SELinux. На самом деле, это домен по
      умолчанию пользователя, который залогинился в системе. Во многих
      случаях, нам стоит использовать тип *unconfined\_user\_t*, а не
      *unconfined\_t*.
    | По умолчанию, существует довольно много неограниченных
      (unconfined) доменов в системе с SELinux Targeted. Мы их завели,
      чтобы пользователи могли запускать ПО/сервисы без вмешательства
      SELinux, если SELinux не знает о них. Вы можете просмотреть список
      всех неограниченных (unconfined) доменов в вашей системе с помощью
      этой команды:

    ::

        seinfo -aunconfined_domain_type -x

    | 
    | В RHEL6 и старых версиях Fedora, мы запускали сервисы с типом
      *initrc\_t* по умолчанию. Ну, конечно, если кто-нибудь не написал
      для них специальное правило. Тип *initrc\_t*, это по умолчанию
      неограниченный (unconfined) домен, пока вы не отключаете
      *unconfined.pp* модуль. Запуск неизвестных сервисов, как
      *initrc\_t*, позволяет администраторам запускать приложение даже
      если для него не было написано правила.

    | В RHEL6 есть такие правила:

    ::

        init_t @initrc_exec_t -> initrc_t
        init_t @bin_t -> initrc_t

    | 
    | Если администратор добавляет исполняемый файл в */usr/sbin* или
      */usr/bin*, то init-система может запустить этот сервис с типом
      *initrc\_t*.
    | Однако, мы обнаружили проблему.

    | Проблема в том, что есть слишком много правил перехода из домена
      *initrc\_t* в другой домен. Например, если программа, о которой мы
      ничего не знаем, запущена в домене *initrc\_t*, и она запускает,
      например, *rsync* чтобы скопировать данные между серверами, то
      SELinux переведет программу в домен *rsync\_t*, и всё поломается
      наглухо. SELinux ошибочно посчитает, что *rsync* был настроен в
      серверном режиме, не в клиентском. Другие правила перехода также
      приведут к поломкам.

    | Мы решили, что нам нужен новый неограниченный (unconfined) домен
      для запуска сервисов, и в котором не будет никаких правил перехода
      в другие домены. Поэтому мы создали домен
      *unconfined\_service\_t*. Теперь у нас есть такое правило:

    ::

        init_t @bin_t -> unconfined_service_t

    | 
    | Процессу, запущенному как *unconfined\_service\_t*, разрешено
      запускать другие ограниченные программы, но он сам остается в
      домене *unconfined\_service\_t*. SELinux не будет блокировать
      доступ. Это значит, что если вы установили сервис, для которого не
      написано никаких правил, то он будет работать без препятствий со
      стороны SELinux.

    | Иногда приложения устанавливаются в нестандартные директории
      внутри */usr* или */opt* (или в случае Oracle даже в */u01*), что
      заканчивается маркировкой приложения как *usr\_t*, поэтому мы
      добавили следующие правила перевода из домена в домен:

    ::

        # sesearch -T -s init_t  | grep unconfined_service_t
        type_transition init_t bin_t : process unconfined_service_t;
        type_transition init_t usr_t : process unconfined_service_t;

    | 
    | Вы можете их найти уже в Fedora 21.

    | **Подводя итог**
    | Будем надеяться, что *unconfined\_service\_t* упростит работу с
      неотключенным SELinux на системах, на которых приходится запускать
      сервисы от сторонних разработчиков, и позволит защищать прочие
      сервисы, запущенные на ваших системах.

    | Примечание:
    | Автор благодарен Simon Sekidde и Miroslav Grepl за помощь в
      создании этой заметки.

