.. title: Добавление Linux-специфичного API в Glibc
.. slug: Добавление-linux-специфичного-api-в-glibc
.. date: 2014-11-24 11:02:23
.. tags:
.. category:
.. link:
.. description:
.. type: text
.. author: Peter Lemenkov

**Это архивная статья**


Когда речь идет про low level API, то как правило говорят про Glibc. Но
на самом деле библиотека просто отдает наверх то, что выдается ей ядром
системы. Есть такой механизм,
`syscalls <http://man7.org/linux/man-pages/man2/syscalls.2.html>`__, и
Glibc оборачивает функции ядра просто вызовом
`syscall <http://man7.org/linux/man-pages/man2/syscall.2.html>`__,
например, чтобы реализовать функцию *ssize\_t read(int fd, void\* buf,
size\_t len)* это делается примерно вот так:
`` nread = syscall(SYS_read, fd, buf, len);``
Вместо использования оберток Glibc можно дергать эти функции самому
напрямую из ядра с помощью
`syscall <http://man7.org/linux/man-pages/man2/syscall.2.html>`__, хотя
почти всегда это нецелесообразно - ведь Glibc не просто оборачивает их,
но и выполняет много других проверок (корректность аргументов,
32/64-битность и прочее). Но порой приходится, т.к. обертки в Glibc
просто нет. Ядро Linux предоставляет огромное количество функций, и
далеко не все из них имеют аналоги в API Glibc. Возникает вопрос, а
почему какие-то функции экспортированы, а какие-то нет?
Раньше, когда Glibc управлял Ulrich `"Stop
Reopening" <https://sourceware.org/bugzilla/show_bug.cgi?id=4980#c23>`__
Drepper, он и решал - эту функцию включаем, а эту нет. После его ухода
из Red Hat на заработки к финансовым спекулянтам в Goldman Sachs, когда
процесс разработки Glibc упорядочился и оздоровился, народ начал
обсуждать, а каковы могут быть формальные критерии для создания обертки
для функции из ядра?
Одной из проблем является мало кому нужная кроссплатформенность Glibc.

Дело в том, что несмотря на то, что в несовместимых между собой
операционных системах семейства BSD, проприетарных Unix-системах, и т.п.
используется свой аналог Libc, разработчики Glibc с непонятным упорством
пытаются обеспечить кроссплатформенность библиотеки - спроса на это
практически никакого, но работа ведется. Практика показывает, что
кроссплатформенный аналог всегда проигрывает нативному, т.к. вынужден
опираться на общее подмножество функционала всех систем, на которых он
работает. Поэтому в коде будет полно кусков, облепленных ifdef, в
которых по каждой ветке будут неисправленные ошибки, уже давно
отсутствующие в других ветках. Хочется добавлять интересный
Linux-функционал, но это сразу будет уводить Glibc от его сборок для
альтернативных ядер. И даже когда функционал добавляется, его не
используют в userspace, т.к. люди боятся обидеть шумных представителей
меньшинств с нетрадиционными системами, которые запросто могут начать
собирать на киллера. Поэтому Linux-специфичный API повисает мертвым
грузом с одним или двумя пользователями, потому что любители юниксвэя
закричат любую попытку его использования в популярных приложениях.

Однако и здесь в обществе уже начало брезжить понимание, например
`Debian начал робко отказываться от комбинаций userspace и
ядер </content/debian-отказался-от-kfreebsd>`__, которые сдерживают его
развитие, хотя до полного отказа от поддержки альтернативных игрушечных
систем еще очень далеко.

Обсуждая невостребованную кроссплатформенность Glibc и аналоги в
несовместимых между собой вариантах BSD нельзя не упомянуть религиозную
суть вопроса. Мы ее не будем раскрывать, т.к. боимся ненависти со
стороны фанатиков, и просто предложим подумать, о том, насколько может
быть конструктивна техническая дискуссия с людьми, приписывающими везде
GNU к названию ядра дистрибутива и ходящими босиком, или с людьми,
переписывающими утилиты ls и cp, т.к. им показалось, что лицензия
недостаточно открытая.

Так или иначе, но несмотря на все проблемы, интересный Linux-специфичный
функционал в Glibc продолжал появляться все время, и обсуждение того,
как бы формализовать его появление тоже шло. Все сдвинулось с мертвой
точки в конце 2012 - начале 2013 года, когда гентушник Mike Frysinger
`выписал доводы за и против включения дополнительного API ядра в
Glibc <http://thread.gmane.org/gmane.comp.lib.glibc.alpha/28894>`__.

Тогда результата не получилось, т.к. вопрос серьезный и всплыло много
нюансов - дополнительная библиотека liblinux, как поступать на
"стабильных" и "сертифицированных" (т.е. замороженных, старых и глючных)
дистрибутивах, как поддерживать альтернативные архитектуры (а почему бы
и никак не поддерживать и их?) и много чего еще.

Недавнее включение (обновление) поддержки futex в Glibc `вновь плавно
привело к идее формального описания критериев для добавления
Linux-специфичного
API <http://thread.gmane.org/gmane.comp.lib.glibc.alpha/45178/focus=46026>`__.

На этот раз дело дошло до
`документации <http://thread.gmane.org/gmane.comp.lib.glibc.alpha/46039>`__.

В целом народ согласен с документом - пора бы начать добавлять API из
Linux без оглядки на совместимость с каким-нибудь TruOpenUnixWorks. Из
забавного, `появление и обсуждение этого RFC затормозило включение в
Glibc функционала для поддержки
kdbus <http://thread.gmane.org/gmane.comp.lib.glibc.alpha/45884/focus=46926>`__.

