.. title: Linux Capabilities и Tame из OpenBSD
.. slug: linux-capabilities-и-tame-из-openbsd
.. date: 2015-07-22 17:38:55
.. tags:
.. category:
.. link:
.. description:
.. type: text
.. author: Peter Lemenkov

**Это архивная статья**


| В Linux хватает возможностей улучшить безопасность приложения. Это и
  разделение по пользователям, и chroot, и SELinux, и capabilities, и
  много чего еще. Само собой, идеального и подходящего всем варианта
  нет, а то, что есть, работает порой не очень интуитивно. Причем
  "интуитивно" даже для опытных разработчиков.

| Приведем простой пример. Приложение запускается от пользователя - как
  ему позволить выполнить привилегированную операцию? Ну, например,
  `открыть порт
  80 <https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-1024-on-l>`__?
  Стандартный способ на сегодняшний день, начиная с RHEL 6, это
  установить на исполняемый файл нужные capabilities:

::

    /usr/sbin/setcap 'cap_net_bind_service=+ep' /usr/bin/myexecutable

| 
| Что такое, *cap\_net\_bind\_service=+ep* предлагаем почитать в *`man 7
  capabilities <http://man7.org/linux/man-pages/man7/capabilities.7.html>`__*
  и в *`man 3
  cap\_from\_text <http://linux.die.net/man/3/cap_from_text>`__*. Раньше
  громоздили еще более странные конструкции - вы можете погуглить по
  "ports less than 1024", "bind to privileged ports" и т.п.
| Это работает, но есть нюанс. Любой пользователь, кто может запустить
  помеченный таким образом исполняемый файл, получается, что может и
  открыть привилегированный порт. Чтоб не смог, надо сменить у
  исполняемого файла группу, сделать -x этой группе, и добавить
  нежелательных пользователей в эту группу (`про этот трюк с группами вы
  уже могли слышать </content/Короткие-новости-34>`__). Исполняемый файл
  можно куда-нибудь скопировать, но он потеряет capabilities,
  привязанные к файловому пути.

| А можно ли лучше? Скажем, запустить исполняемый файл с помощью
  fork+exec, и как-то добавить нужные capabilities перед exec или еще
  где-нибудь? Вот этот вопрос как раз и
  `обеспокоил <https://thread.gmane.org/gmane.linux.redhat.fedora.devel/209431>`__
  нашего коллегу, `Florian Weimer <https://github.com/fweimer>`__.

  Интересно, что `в systemd есть пара интересных директив -
  CapabilityBoundingSet и
  Capabilities <http://www.freedesktop.org/software/systemd/man/systemd.exec.html>`__,
  и о них даже `упоминает Lennart
  Poettering <http://0pointer.de/blog/projects/security.html>`__, но они
  позволяют делать обратное - отбирать capabilities у запущенного от
  суперпользователя процесса, а не добавлять capabilities в процесс,
  запущенный от непривилегированного пользователя.

| На самом деле, это известная проблема, и те, кто по разным причинам не
  хотят ставить метку на исполняемый файл, громоздят страшно выглядящие
  конструкции в своих service-файлах - к примеру, `использовать iptables
  чтобы дать доступ к порту 80 непривилегированному
  процессу <https://gist.github.com/lemenkov/068254bba7731bd5694a>`__. В
  случае с портами можно еще использовать `socket activation для
  контейнеров <http://0pointer.de/blog/projects/socket-activated-containers.html>`__,
  но даже это порой требует модификации исполняемого файла. Но насчет
  того, можно ли добавить capabilities в процесс, запущенный от простого
  пользователя, чтобы решить задачу в общем случае, `Andy
  Lutomirski <https://www.linkedin.com/pub/andrew-lutomirski/4/752/18>`__
  ответил однозначно - `нет, это
  невозможно <https://thread.gmane.org/gmane.linux.redhat.fedora.devel/209431/focus=209438>`__.

  Придется ждать до Linux 4.3, где появятся `ambient
  capabilities <https://thread.gmane.org/gmane.linux.kernel.api/9023>`__,
  над которым как раз и работает Andy.

| Таким образом прямо сейчас функционал capabilities, если не
  использовать метки на исполняемых файлах, позволяет лишь в runtime
  уменьшать `поверхность
  атаки <https://ru.wikipedia.org/wiki/Поверхность_атаки>`__ для
  процессов, запущенных от суперпользователя. Это, разумеется, серьезное
  архитектурное ограничение. Мы даже и не ожидали, что Theo de Raadt
  возьмет за базовую модель для `недавно предложенного
  Tame <https://thread.gmane.org/gmane.os.openbsd.tech/43085>`__ именно
  Linux capabilities.

| Вообще, мы привыкли, что идеи, предложенные нашими друзьями,
  растаскиваются нашими критиками, когда те дорастают до понимания
  предметной области. Например, после шумной критики systemd, аналог
  начали реализовывать и в FreeBSD (`вы недавно могли об этом
  слышать </content/Новости-systemd-2>`__), и даже в `Haiku (открытый
  аналог Amiga
  OS) <https://www.haiku-os.org/blog/axeld/2015-07-17_introducing_launch_daemon>`__.

  Это, конечно, `сделало неактуальным наш совет
  systemd-хейтерам </content/Новости-systemdlinux-платформы>`__, но тут
  ничего не поделаешь.

| Так вот, изначально были предложения разработать для OpenBSD аналог
  seccomp из Linux (`например
  тут <https://thread.gmane.org/gmane.os.openbsd.tech/41898>`__), но Theo
  высказал соображение, что `писать программу для того, чтобы
  обезопасить другую программу, это
  нерационально <https://thread.gmane.org/gmane.os.openbsd.tech/41898/focus=41904>`__.

  После этого, из вариантов был лишь один - `составить список
  привилегий <http://linux.die.net/man/7/capabilities>`__, необходимых
  для каких-то действий (причем ограничиться списком, который показался
  разумным для Theo), и представить функцию для установки флагов.

  Выглядит это очень `похоже на
  capabilities <https://plus.google.com/103747673045238156202/posts/DPfqjKPsbkb>`__,
  за исключением заведомо урезанного API. Ну, что-то типа покрывает 80%
  функционала за 20% реализации. Первый вариант в процессе рассмотрения,
  так что схожесть по функционалу (и, соответственно, по объему
  реализации) может и возрасти.

| К сожалению, специалисты по безопасности, мельком глянув на
  предложенный вариант реализации, уже нашли фундаментальные ошибки.

  Проблемы с архитектурой и ее качеством исполнения совершенно
  неудивительны, учитывая все сокращающееся количество
  BSD-разработчиков, вдобавок к этому более-менее равномерно
  распределенное среди дюжины несовместимых форков BSD. `Brad
  Spengler <https://twitter.com/grsecurity>`__ замечает, что это не
  первый случай полурабочей реализации в OpenBSD функционала из других
  операционных систем, и `делает
  вывод <https://lwn.net/Articles/651894/>`__:

    ...наивный минималистический подход на основе syscall обязательно
    столкнется с проблемой - любая более-менее сложная программа
    обязательно потребует столько привилегий, что ей хватит, чтобы
    "выстрелить себе в ногу". ...возможно Tame будет достаточно для
    неинтерактивно работающего на i386-машине файерволла (типичная
    инсталляция OpenBSD), но на реальный мир и реальные приложения такой
    подход не перенести. Если Tame не защищает от простейшего
    наколеночного эксплойта, тогда в чем его смысл, кроме иллюзии
    применимости OpenBSD для приложений безопасности?

| 
